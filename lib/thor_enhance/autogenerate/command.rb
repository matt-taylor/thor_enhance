# frozen_string_literal: true

require "active_support/core_ext/string/inflections"
require "thor_enhance/autogenerate/option"
require "erb"

module ThorEnhance
  module Autogenerate
    class Command
      COMMAND_ERB = "#{File.dirname(__FILE__)}/templates/command.rb.erb"
      COMMAND_TEMPLATE = ERB.new(File.read(COMMAND_ERB))

      AGGREGATE_OPTIONS_ERB = "#{File.dirname(__FILE__)}/templates/aggregate_options.rb.erb"
      AGGREGATE_OPTIONS_TEMPLATE = ERB.new(File.read(AGGREGATE_OPTIONS_ERB))

      CLASS_OPTIONS_ERB = "#{File.dirname(__FILE__)}/templates/class_options.rb.erb"
      CLASS_OPTIONS_TEMPLATE = ERB.new(File.read(CLASS_OPTIONS_ERB))

      FOOTER_ERB = "#{File.dirname(__FILE__)}/templates/footer.rb.erb"
      FOOTER_TEMPLATE = ERB.new(File.read(FOOTER_ERB))

      attr_reader :root, :leaf, :name, :basename, :child_commands, :parent

      def initialize(leaf:, name:, basename:, root: , parent: nil)
        @leaf = leaf
        @name = name
        @basename = basename
        @child_commands = []
        @parent = parent
        @root = root
        initialize_children!
      end

      def initialize_children!
        return unless children?

        @child_commands = leaf.children.map do |name, child_leaf|
          self.class.new(root: root, leaf: child_leaf, name: name, basename: basename, parent: self)
        end
      end

      def method_options
        @method_options ||= begin
          _options = options.map { |name, option| Option.new(name: name, option: option) }
          _options = _options.group_by { _1.readme_type }
          unless _options.empty?
            _options.delete(ThorEnhance.configuration.autogenerated_config.readme_skip_key)
          end

          _options
        end
      end

      def command_erb
        @command_erb ||= begin
          params = {
            all_bases: all_bases,
            basename_string: basename_string,
            children_descriptors: children_descriptors,
            class_options_erb: class_options_erb,
            command: command,
            command_source: command_source,
            custom_headers: custom_headers,
            default_command: default_command,
            default_command_string: default_command_string,
            description: description,
            drawn_out_examples: drawn_out_examples,
            footer_erb: footer_erb,
            headers: headers,
            method_options_erb: method_options_erb,
            parent_basename_string: parent_basename_string,
            preferred_basename_string: preferred_basename_string,
            title: title,
          }
          COMMAND_TEMPLATE.result_with_hash(params)
        end
      end

      def command_source
        # if children exists, it is a subcommand
        # source location for a command does not accurately find the correct source
        # Return nil and skip output
        return nil if children?

        file, line = leaf.base.instance_method(name).source_location
        # this will return the relative location of the command source line
        relative_source = file.split("/") - root.split("/")
        relative_link = "/#{relative_source.join("/")}#L#{line}"
        "Source code for this command can be found at: [#{leaf.base.name}##{name}](#{relative_link})"
      end

      def footer_erb
        @footer_erb ||=  begin
          regenerate_thor_command = "#{basename} thor_enhance_autogenerate --apply"
          FOOTER_TEMPLATE.result_with_hash({ regenerate_thor_command: regenerate_thor_command })
        end
      end

      def drawn_out_examples(with_desc: true)
        case command.example
        when nil
        when Array
          command.example.map do |example|
            value = []
            value << "# #{example[:arguments][:kwargs][:desc]}" if with_desc
            value << "#{parent_basename_string} #{example[:input]}"
            value.join("\n")
          end
        else
          value = []
          value << "# #{example[:arguments][:kwargs][:desc]}" if with_desc
          value << "#{parent_basename_string} #{example[:input]}"
          [value.join("\n")]
        end
      end

      def method_options_erb
        @method_options_erb ||= AGGREGATE_OPTIONS_TEMPLATE.result_with_hash({ method_options: method_options })
      end

      def class_options_erb
        @class_options_erb ||= begin
          if class_options.empty?
            nil
          else
            CLASS_OPTIONS_TEMPLATE.result_with_hash({ method_options_text_array: class_options.map(&:template_text) })
          end
        end
      end

      def class_options
        leaf.base.class_options.map do |name, class_option|
          class_option.hide ? nil : Option.new(name: name, option: class_option)
        end.compact
      end

      def basename_string
         "#{parent_basename_string} #{command.usage}"
      end

      def default_command_string
        parent_basename_string if name == default_command
      end

      def all_bases
        [default_command_string, basename_string].compact
      end

      def preferred_basename_string
        default_command_string || basename_string
      end

      def parent_basename_string
        parent_names = [basename]
        temp_leaf = leaf
        while parent = temp_leaf.parent
          temp_leaf = parent
          parent_names << parent.command.usage
        end
        parent_names.join(" ")
      end

      def parent_root
        if parent
          # Remove the last index of parent because that will be the Readme.md file
          # We just want the directory of the parent file
          parent.relative_readme_path[0..-2]
        else
          []
        end
      end

      def relative_readme_path
        if children?
          # If children exist, this is a subcommand and needs to be a root ReadMe
          [*parent_root, name, "Readme.md"]
        else
          [*parent_root, "#{name}.md"]
        end
      end

      # this only returns children and its children
      # Call this on top most parent to retreive family tree for subcommands
      def flatten_children
        return [] if child_commands.empty?

        child_commands.map do |child|
          [child, child.flatten_children]
        end.flatten
      end

      def save_self!(root:, apply:)
        absolute_path = "#{root}/#{relative_readme_path.join("/")}"
        pathname = Pathname.new(absolute_path)
        FileUtils.mkdir_p(pathname.dirname)
        if File.exist?(absolute_path)
          content = File.read(absolute_path)
          diff = command_erb == content ? :same : :overwite
        else
          diff = :new
        end

        if apply
          File.write(absolute_path, command_erb)
        end

        { path: absolute_path, diff: diff, apply: apply, self_for_root: self_for_root }
      end

      def description
        command.long_description || command.description
      end

      def title
        command.title&.dig(:input) || command.usage
      end

      def self_for_root
        params_for_child(self)
      end

      def default_command
        if children?
          leaf.base.subcommand_classes[name].default_task
        else
          leaf.base.default_task
        end
      rescue
        nil
      end

      private

      def custom_headers
        ThorEnhance.configuration.autogenerated_config.custom_headers.map do |header|
          next unless command.respond_to?(header.to_sym)

          header_value = command.public_send(header.to_sym)
          next if header_value.nil?
          case header_value
          when Array
            header_value.map { header_string(_1, header) }
          else
            header_string(header_value, header)
          end

        end.compact.flatten.join("\n\n")
      end

      def header_string(header_value, header)
        header_name = header.to_s.gsub(/[_-]/, " ").titlecase
        header_name += "?" if ThorEnhance.configuration.autogenerated_config.question_headers.include?(header)
        header_tag = decipher_header_tag(header_value[:arguments][:kwargs][:tag])
        header_input = header_value[:input]
        "#{header_tag} #{header_name}\n\n#{header_input}"
      end

      def decipher_header_tag(input)
        case input
        when String
          begin
            input[0..1][-1].to_i.to_s == input[0..1][-1] ? "#" * input[0..1][-1].to_i : "##"
          rescue
            "##"
          end
        when Integer
          "#" * input
        else
          "##"
        end
      end

      def children_descriptors
        default = child_commands.map { params_for_child(_1) }.select { _1[:default_command] }
        not_default = child_commands.map { params_for_child(_1) }.select { !_1[:default_command] }
        default + not_default
      end

      def params_for_child(child)
        relative_link = find_iterations_back(child)
        link = child.relative_readme_path[relative_link..-1].join("/")
        {
          all_bases: child.all_bases,
          basename_string: child.basename_string,
          default_command: child.name == default_command,
          default_command_string: default_command_string,
          description: child.description,
          examples: child.drawn_out_examples(with_desc: false) || [],
          link: link,
          preferred_basename_string: child.preferred_basename_string,
          title: child.title,
        }
      end

      def find_iterations_back(child)
        # if parent is not present, then start from 0th position
        return 0 if child.parent.nil?
        # When there is no children, just take the last
        return -1 unless child.leaf.children?

        # when parent exists, find out how many parents there are
        # Return how many parents there are
        iterations = -1
        temp_child = child
        while temp = temp_child.parent
          iterations -= 1
          temp_child = temp_child.parent
        end

        iterations
      end

      def headers
        (command.header || []).map { _1[:arguments][:kwargs] }
      end

      def children?
        leaf.children?
      end

      def command
        leaf.command
      end

      def options
        command.options.reject { |name, option| option.hide}
      end
    end
  end
end
